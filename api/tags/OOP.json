{"name":"OOP","slug":"OOP","count":5,"postlist":[{"title":"SOLID原則:依賴反轉原則(Dependency Inversion Principle)","slug":"DIP","date":"2024-03-19T09:41:48.000Z","updated":"2024-05-18T01:06:16.315Z","comments":true,"path":"api/articles/DIP.json","excerpt":"<h1 id=\"依賴反轉原則\"><a href=\"#依賴反轉原則\" class=\"headerlink\" title=\"依賴反轉原則\"></a>依賴反轉原則</h1><p>類別之間的依賴盡量以<code>Interface</code>的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低層次的模組上）形式，使得高層次的模組不依賴於低層次的模組的實現細節，依賴關係被顛倒（反轉），從而使得低層次模組依賴於高層次模組的需求抽象。</p>","keywords":null,"cover":null,"content":null,"text":"依賴反轉原則類別之間的依賴盡量以Interface的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:接口隔離原則(Interface Segregation Principle)","slug":"ISP","date":"2024-03-19T09:38:48.000Z","updated":"2024-05-18T01:06:26.172Z","comments":true,"path":"api/articles/ISP.json","excerpt":"<h1 id=\"介面隔離原則\"><a href=\"#介面隔離原則\" class=\"headerlink\" title=\"介面隔離原則\"></a>介面隔離原則</h1><p>介面隔離原則是這樣被描述的:</p>\n<blockquote>\n<p>不應該強制客戶端依賴於它們不用的介面</p>\n</blockquote>\n<p>介面隔離原則主要解決介面過於擁擠的問題。建立介面保持簡潔、最低限度的功能。</p>","keywords":null,"cover":null,"content":null,"text":"介面隔離原則介面隔離原則是這樣被描述的:不應該強制客戶端依賴於它們不用的介面介面隔離原則主要解決介面過於擁擠的問題。建立介面保持簡潔、最低限度的功能。舉掃描介面來說:IScan.cs1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br><br>publi","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:里氏替換原則(Liskov Substitution Principle)","slug":"LSP","date":"2024-03-19T09:34:48.000Z","updated":"2024-05-18T01:06:36.720Z","comments":true,"path":"api/articles/LSP.json","excerpt":"<h1 id=\"里氏替換原則\"><a href=\"#里氏替換原則\" class=\"headerlink\" title=\"里氏替換原則\"></a>里氏替換原則</h1><p>里式替換原則描述:</p>\n<blockquote>\n<p>子類別應該可以替換父類並且行為不會受到影響。</p>\n</blockquote>\n<p>在原本的里式替換原則之中，如果子類別無法替換父類別，就會出現程式上的錯誤。子類別必須完全替代父類別，並不會影響原有的程式邏輯。里氏替換原則適用於繼承和介面的應用，藉此實現程式碼的可擴展性和重用性。</p>","keywords":null,"cover":null,"content":null,"text":"里氏替換原則里式替換原則描述:子類別應該可以替換父類並且行為不會受到影響。在原本的里式替換原則之中，如果子類別無法替換父類別，就會出現程式上的錯誤。子類別必須完全替代父類別，並不會影響原有的程式邏輯。里氏替換原則適用於繼承和介面的應用，藉此實現程式碼的可擴展性和重用性。最常見的例","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:開放封閉原則(Open Close Principle)","slug":"OCP","date":"2024-03-19T09:23:48.000Z","updated":"2024-05-18T01:06:46.228Z","comments":true,"path":"api/articles/OCP.json","excerpt":"<h1 id=\"開放封閉原則\"><a href=\"#開放封閉原則\" class=\"headerlink\" title=\"開放封閉原則\"></a>開放封閉原則</h1><p>開放封閉原則在 <em>Clean Architecture</em> 一書中是這樣被敘述的</p>\n<blockquote>\n<p>一個軟體製品應該對於擴充是開放的，但對於修改是封閉的。</p>\n</blockquote>\n<p>一個簡單的擴充需求，對於軟體開發上是巨大的改變。這是軟體架構的失敗。一個好的軟體架構可以將修改的程式碼減少到最低程度。在理想情形下這個值是 <strong>0</strong>。</p>","keywords":null,"cover":null,"content":null,"text":"開放封閉原則開放封閉原則在 Clean Architecture 一書中是這樣被敘述的一個軟體製品應該對於擴充是開放的，但對於修改是封閉的。一個簡單的擴充需求，對於軟體開發上是巨大的改變。這是軟體架構的失敗。一個好的軟體架構可以將修改的程式碼減少到最低程度。在理想情形下這個值是 ","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:單一職責原則(Single Responsibility Principle)","slug":"SRP","date":"2024-03-19T09:20:48.000Z","updated":"2024-05-18T01:06:54.669Z","comments":true,"path":"api/articles/SRP.json","excerpt":"<h1 id=\"單一職責原則-Single-Responsibility-Principle\"><a href=\"#單一職責原則-Single-Responsibility-Principle\" class=\"headerlink\" title=\"單一職責原則(Single Responsibility Principle)\"></a>單一職責原則(Single Responsibility Principle)</h1><blockquote>\n<p>一個模組應該只對唯一的一個角色負責</p>\n</blockquote>\n<p>一個類別或模塊只應該負責一個功能或職責。這個原則有助於降低代碼的複雜度，使代碼更容易維護和擴展。這避免了一個類別出現了上帝類別（God Class)。</p>","keywords":null,"cover":null,"content":null,"text":"單一職責原則(Single Responsibility Principle)一個模組應該只對唯一的一個角色負責一個類別或模塊只應該負責一個功能或職責。這個原則有助於降低代碼的複雜度，使代碼更容易維護和擴展。這避免了一個類別出現了上帝類別（God Class)。舉例來說，這是一個","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]}]}