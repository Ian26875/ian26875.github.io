{"title":"SOLID原則:依賴反轉原則(Dependency Inversion Principle)","slug":"DIP","date":"2024-03-19T09:41:48.000Z","updated":"2024-05-18T01:06:16.315Z","comments":true,"path":"api/articles/DIP.json","photos":[],"link":"","excerpt":"依賴反轉原則類別之間的依賴盡量以Interface的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低層次的模組上）形式，使得高層次的模組不依賴於低層次的模組的實現細節，依賴關係被顛倒（反轉），從而使得低層次模組依賴於高層次模組的需求抽象。","covers":null,"content":"<h1 id=\"依賴反轉原則\"><a href=\"#依賴反轉原則\" class=\"headerlink\" title=\"依賴反轉原則\"></a>依賴反轉原則</h1><p>類別之間的依賴盡量以<code>Interface</code>的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低層次的模組上）形式，使得高層次的模組不依賴於低層次的模組的實現細節，依賴關係被顛倒（反轉），從而使得低層次模組依賴於高層次模組的需求抽象。</p>\n<span id=\"more\"></span>\n\n<p>該原則規定：</p>\n<ul>\n<li>高層次的模組不應該依賴於低層次的模組，兩者都應該依賴於抽象介面。</li>\n<li>抽象介面不應該依賴於具體實現。而具體實現則應該依賴於抽象介面。</li>\n</ul>\n<h2 id=\"穩定的介面\"><a href=\"#穩定的介面\" class=\"headerlink\" title=\"穩定的介面\"></a>穩定的介面</h2><p>介面的改變會影響到實作，反之，對於修改實作不一定會去修改介面。甚至都不要去修改介面，因此介面比實作穩定。</p>\n<p>舉例如下:</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">OrderService</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderRepository _orderRepository;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrderService</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _orderRepository = <span class=\"keyword\">new</span> OrderRepository();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">GetAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> orderId</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">         </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> order = <span class=\"keyword\">await</span> _orderRepository.GetAsync(orderId);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 略 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>對於這樣的程式碼 <code>OrderService.cs</code> 直接依賴 <code>OrderRepository.cs</code>，容易導致<code>OrderRepository.cs</code>的修改直接影響到<code>OrderService.cs</code>。尤其是當<code>OrderRepository.cs</code>的實作有調整時，會造成<code>OrderService.cs</code>的修改。在需求異動時，我們應該以最少的修改完成需求。</p>\n<p>我們應該可以把OrderRepository抽取介面，並依賴介面。</p>\n<p>建立 <code>IOrderRepository.cs</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IOrderRepository</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Task <span class=\"title\">GetAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> orderId</span>)</span>;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>讓 <code>OrderRepository.cs</code> 實作 <code>IOrderRepository.cs</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">OrderRepository</span> : <span class=\"title\">IOrderRepository</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">GetAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> orderId</span>)</span></span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"comment\">//略</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>OrderService.cs</code> 直接依賴 <code>IOrderRepository.cs</code> 而不直接依賴 <code>OrderRepository.cs</code></p>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>在類別層次上，符合依賴反轉原則的設計需要透過抽象化來定義穩定的介面，讓高層類別依賴於介面，而不是依賴於具體的低層類別。這樣可以降低高層組件對低層組件的依賴程度，並且使得系統更容易進行修改和擴展。</p>\n<p>在架構層次上，依賴反轉原則要求將系統中的依賴關係建立在抽象的邊界上。這意味著不同的組件應該依賴於抽象的介面或類別，而不是具體的實現細節。透過定義穩定的介面和抽象層次，不同組件之間的依賴關係可以更加清晰和靈活，並且可以簡化組件之間的協作和整合。</p>\n<p>當所有的類別都依賴於穩定的介面時，依賴反轉原則提供了一個架構上的邊界，並且定義了新的依賴規則。這樣的依賴規則使得高層組件和低層組件之間的依賴關係變得清晰和可管理，提高了系統的彈性和可擴展性。</p>\n<p>因此，依賴反轉原則在類別層次和架構層次上都非常重要，它的目的都是解耦合系統的不同組件，建立抽象的介面和層次，提高系統的靈活性、可擴展性和可測試性。</p>\n","categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]}