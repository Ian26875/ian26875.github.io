{"total":20,"pageSize":10,"pageCount":2,"data":[{"title":"Swagger 文件加上FluentValidation驗證規則","slug":"Swagger_3","date":"2024-05-18T01:15:48.000Z","updated":"2024-05-18T01:04:28.419Z","comments":true,"path":"api/articles/Swagger_3.json","excerpt":"<h1 id=\"Swagger-文件加上FluentValidation驗證規則\"><a href=\"#Swagger-文件加上FluentValidation驗證規則\" class=\"headerlink\" title=\"Swagger 文件加上FluentValidation驗證規則\"></a>Swagger 文件加上FluentValidation驗證規則</h1><h6 id=\"tags-NuGet-Package\"><a href=\"#tags-NuGet-Package\" class=\"headerlink\" title=\"tags: NuGet Package\"></a>tags: <code>NuGet Package</code></h6><p>MicroElements.Swashbuckle.FluentValidation 是一個 Swagger 擴展庫，它提供了一個便利的方法來顯示 FluentValidation 驗證器的錯誤信息，使得 Swagger API 文檔更加友好和易於使用。</p>\n<p>具體而言，MicroElements.Swashbuckle.FluentValidation 可以自動從 FluentValidation 驗證器中提取錯誤信息，並將其顯示在 Swagger UI 的輸入欄位旁邊，以便用戶更快速地找到並修復錯誤。</p>","keywords":null,"cover":null,"content":null,"text":"Swagger 文件加上FluentValidation驗證規則tags: NuGet PackageMicroElements.Swashbuckle.FluentValidation 是一個 Swagger 擴展庫，它提供了一個便利的方法來顯示 FluentValidatio","link":"","raw":null,"photos":[],"categories":[{"name":"WebAPI","slug":"WebAPI","count":6,"path":"api/categories/WebAPI.json"},{"name":"OpenAPI","slug":"WebAPI/OpenAPI","count":3,"path":"api/categories/WebAPI/OpenAPI.json"}],"tags":[{"name":".Net Core","slug":"Net-Core","count":10,"path":"api/tags/Net-Core.json"},{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OpenAPI","slug":"OpenAPI","count":3,"path":"api/tags/OpenAPI.json"}]},{"title":"Swagger 文件加上範例格式資料","slug":"Swagger_2","date":"2024-05-18T01:10:48.000Z","updated":"2024-05-18T01:04:22.005Z","comments":true,"path":"api/articles/Swagger_2.json","excerpt":"<h1 id=\"Swagger-文件加上範例格式資料\"><a href=\"#Swagger-文件加上範例格式資料\" class=\"headerlink\" title=\"Swagger 文件加上範例格式資料\"></a>Swagger 文件加上範例格式資料</h1><h6 id=\"tags-NuGet-Package\"><a href=\"#tags-NuGet-Package\" class=\"headerlink\" title=\"tags: NuGet Package\"></a>tags: <code>NuGet Package</code></h6><p>Swashbuckle.AspNetCore.Filters 是一個 Swagger 擴充庫，提供一組有用的Attribute和工具，可以幫助開發人員更輕鬆地使用 Swagger 和 .NET Core 開發 Web API。</p>\n<p>其中的 ExampleProvider 是一個介面，用於定義如何生成 Swagger API 文檔中的範例資料。具體而言，ExampleProvider 提供了一種方法，即 <code>GetExamples()</code>，該方法返回物件，其中包含要顯示在 Swagger API 文檔中的示例數據。通常，開發人員可以實現自己的 ExampleProvider，並使用自定義的邏輯生成範例資料。</p>","keywords":null,"cover":null,"content":null,"text":"Swagger 文件加上範例格式資料tags: NuGet PackageSwashbuckle.AspNetCore.Filters 是一個 Swagger 擴充庫，提供一組有用的Attribute和工具，可以幫助開發人員更輕鬆地使用 Swagger 和 .NET Core 開","link":"","raw":null,"photos":[],"categories":[{"name":"WebAPI","slug":"WebAPI","count":6,"path":"api/categories/WebAPI.json"},{"name":"OpenAPI","slug":"WebAPI/OpenAPI","count":3,"path":"api/categories/WebAPI/OpenAPI.json"}],"tags":[{"name":".Net Core","slug":"Net-Core","count":10,"path":"api/tags/Net-Core.json"},{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OpenAPI","slug":"OpenAPI","count":3,"path":"api/tags/OpenAPI.json"}]},{"title":"Swagger 文件安裝與設定","slug":"Swagger_1","date":"2024-05-18T01:00:48.000Z","updated":"2024-05-18T01:04:12.727Z","comments":true,"path":"api/articles/Swagger_1.json","excerpt":"<h1 id=\"Swagger-文件安裝與設定\"><a href=\"#Swagger-文件安裝與設定\" class=\"headerlink\" title=\"Swagger 文件安裝與設定\"></a>Swagger 文件安裝與設定</h1><h6 id=\"tags-NuGet-Package\"><a href=\"#tags-NuGet-Package\" class=\"headerlink\" title=\"tags: NuGet Package\"></a>tags: <code>NuGet Package</code></h6><p>現今許多 Web API 開發團隊都採用 Swagger 來製作 API 文件，這讓開發人員能夠更加便利地開發和測試 API。使用 Swagger 的好處包括但不限於：清楚的 API 規範、易於閱讀的 API 文件、快速的 API 測試等。此外，Swagger 還支援自動生成客戶端程式碼，使得開發人員能夠更快地建立與 API 互動的應用程式。</p>","keywords":null,"cover":null,"content":null,"text":"Swagger 文件安裝與設定tags: NuGet Package現今許多 Web API 開發團隊都採用 Swagger 來製作 API 文件，這讓開發人員能夠更加便利地開發和測試 API。使用 Swagger 的好處包括但不限於：清楚的 API 規範、易於閱讀的 API 文","link":"","raw":null,"photos":[],"categories":[{"name":"WebAPI","slug":"WebAPI","count":6,"path":"api/categories/WebAPI.json"},{"name":"OpenAPI","slug":"WebAPI/OpenAPI","count":3,"path":"api/categories/WebAPI/OpenAPI.json"}],"tags":[{"name":".Net Core","slug":"Net-Core","count":10,"path":"api/tags/Net-Core.json"},{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OpenAPI","slug":"OpenAPI","count":3,"path":"api/tags/OpenAPI.json"}]},{"title":"Domain Driven Design","slug":"DDD","date":"2024-03-19T10:23:48.000Z","updated":"2024-05-18T01:05:24.672Z","comments":true,"path":"api/articles/DDD.json","excerpt":"<h1 id=\"為什麼需要-Domain-Driven-Design\"><a href=\"#為什麼需要-Domain-Driven-Design\" class=\"headerlink\" title=\"為什麼需要 Domain Driven Design\"></a>為什麼需要 Domain Driven Design</h1><p>隨著系統隨時間演變而逐漸複雜化，其數據和業務概念往往變得混亂，尤其是在公司持續成長的情況下。這種混亂不僅涉及架構的複雜性，還包括業務邏輯的混淆。例如，當業務需求描述為「建立訂單」時，工程師可能需要在代碼中尋找相應的實現位置，而隨著系統的演化，不同的開發者可能會使用不同的命名方式，如 CreateOrder、MakeOrder 和 PlaceOrder，這進一步增加了理解和維護的難度。</p>","keywords":null,"cover":null,"content":null,"text":"為什麼需要 Domain Driven Design隨著系統隨時間演變而逐漸複雜化，其數據和業務概念往往變得混亂，尤其是在公司持續成長的情況下。這種混亂不僅涉及架構的複雜性，還包括業務邏輯的混淆。例如，當業務需求描述為「建立訂單」時，工程師可能需要在代碼中尋找相應的實現位置，而隨","link":"","raw":null,"photos":[],"categories":[{"name":"Domain Driven Design","slug":"Domain-Driven-Design","count":2,"path":"api/categories/Domain-Driven-Design.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"DDD","slug":"DDD","count":2,"path":"api/tags/DDD.json"}]},{"title":"SOLID原則:依賴反轉原則(Dependency Inversion Principle)","slug":"DIP","date":"2024-03-19T09:41:48.000Z","updated":"2024-05-18T01:06:16.315Z","comments":true,"path":"api/articles/DIP.json","excerpt":"<h1 id=\"依賴反轉原則\"><a href=\"#依賴反轉原則\" class=\"headerlink\" title=\"依賴反轉原則\"></a>依賴反轉原則</h1><p>類別之間的依賴盡量以<code>Interface</code>的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低層次的模組上）形式，使得高層次的模組不依賴於低層次的模組的實現細節，依賴關係被顛倒（反轉），從而使得低層次模組依賴於高層次模組的需求抽象。</p>","keywords":null,"cover":null,"content":null,"text":"依賴反轉原則類別之間的依賴盡量以Interface的方式進行溝通，應該減少類別的直接依賴。這樣可以減少修改幅度。<br>依賴反轉原則（Dependency inversion principle，DIP）是指一種特定的解耦（傳統的依賴關係建立在高層次上，而具體的策略設定則應用在低","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:接口隔離原則(Interface Segregation Principle)","slug":"ISP","date":"2024-03-19T09:38:48.000Z","updated":"2024-05-18T01:06:26.172Z","comments":true,"path":"api/articles/ISP.json","excerpt":"<h1 id=\"介面隔離原則\"><a href=\"#介面隔離原則\" class=\"headerlink\" title=\"介面隔離原則\"></a>介面隔離原則</h1><p>介面隔離原則是這樣被描述的:</p>\n<blockquote>\n<p>不應該強制客戶端依賴於它們不用的介面</p>\n</blockquote>\n<p>介面隔離原則主要解決介面過於擁擠的問題。建立介面保持簡潔、最低限度的功能。</p>","keywords":null,"cover":null,"content":null,"text":"介面隔離原則介面隔離原則是這樣被描述的:不應該強制客戶端依賴於它們不用的介面介面隔離原則主要解決介面過於擁擠的問題。建立介面保持簡潔、最低限度的功能。舉掃描介面來說:IScan.cs1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br><br>publi","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:里氏替換原則(Liskov Substitution Principle)","slug":"LSP","date":"2024-03-19T09:34:48.000Z","updated":"2024-05-18T01:06:36.720Z","comments":true,"path":"api/articles/LSP.json","excerpt":"<h1 id=\"里氏替換原則\"><a href=\"#里氏替換原則\" class=\"headerlink\" title=\"里氏替換原則\"></a>里氏替換原則</h1><p>里式替換原則描述:</p>\n<blockquote>\n<p>子類別應該可以替換父類並且行為不會受到影響。</p>\n</blockquote>\n<p>在原本的里式替換原則之中，如果子類別無法替換父類別，就會出現程式上的錯誤。子類別必須完全替代父類別，並不會影響原有的程式邏輯。里氏替換原則適用於繼承和介面的應用，藉此實現程式碼的可擴展性和重用性。</p>","keywords":null,"cover":null,"content":null,"text":"里氏替換原則里式替換原則描述:子類別應該可以替換父類並且行為不會受到影響。在原本的里式替換原則之中，如果子類別無法替換父類別，就會出現程式上的錯誤。子類別必須完全替代父類別，並不會影響原有的程式邏輯。里氏替換原則適用於繼承和介面的應用，藉此實現程式碼的可擴展性和重用性。最常見的例","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:開放封閉原則(Open Close Principle)","slug":"OCP","date":"2024-03-19T09:23:48.000Z","updated":"2024-05-18T01:06:46.228Z","comments":true,"path":"api/articles/OCP.json","excerpt":"<h1 id=\"開放封閉原則\"><a href=\"#開放封閉原則\" class=\"headerlink\" title=\"開放封閉原則\"></a>開放封閉原則</h1><p>開放封閉原則在 <em>Clean Architecture</em> 一書中是這樣被敘述的</p>\n<blockquote>\n<p>一個軟體製品應該對於擴充是開放的，但對於修改是封閉的。</p>\n</blockquote>\n<p>一個簡單的擴充需求，對於軟體開發上是巨大的改變。這是軟體架構的失敗。一個好的軟體架構可以將修改的程式碼減少到最低程度。在理想情形下這個值是 <strong>0</strong>。</p>","keywords":null,"cover":null,"content":null,"text":"開放封閉原則開放封閉原則在 Clean Architecture 一書中是這樣被敘述的一個軟體製品應該對於擴充是開放的，但對於修改是封閉的。一個簡單的擴充需求，對於軟體開發上是巨大的改變。這是軟體架構的失敗。一個好的軟體架構可以將修改的程式碼減少到最低程度。在理想情形下這個值是 ","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"SOLID原則:單一職責原則(Single Responsibility Principle)","slug":"SRP","date":"2024-03-19T09:20:48.000Z","updated":"2024-05-18T01:06:54.669Z","comments":true,"path":"api/articles/SRP.json","excerpt":"<h1 id=\"單一職責原則-Single-Responsibility-Principle\"><a href=\"#單一職責原則-Single-Responsibility-Principle\" class=\"headerlink\" title=\"單一職責原則(Single Responsibility Principle)\"></a>單一職責原則(Single Responsibility Principle)</h1><blockquote>\n<p>一個模組應該只對唯一的一個角色負責</p>\n</blockquote>\n<p>一個類別或模塊只應該負責一個功能或職責。這個原則有助於降低代碼的複雜度，使代碼更容易維護和擴展。這避免了一個類別出現了上帝類別（God Class)。</p>","keywords":null,"cover":null,"content":null,"text":"單一職責原則(Single Responsibility Principle)一個模組應該只對唯一的一個角色負責一個類別或模塊只應該負責一個功能或職責。這個原則有助於降低代碼的複雜度，使代碼更容易維護和擴展。這避免了一個類別出現了上帝類別（God Class)。舉例來說，這是一個","link":"","raw":null,"photos":[],"categories":[{"name":"OOP","slug":"OOP","count":8,"path":"api/categories/OOP.json"},{"name":"SOLID","slug":"OOP/SOLID","count":5,"path":"api/categories/OOP/SOLID.json"}],"tags":[{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"},{"name":"OOP","slug":"OOP","count":5,"path":"api/tags/OOP.json"},{"name":"SOLID","slug":"SOLID","count":5,"path":"api/tags/SOLID.json"}]},{"title":"更高效 Logging - LoggerMessage","slug":"LoggingMessage","date":"2024-02-16T12:19:48.000Z","updated":"2024-05-18T01:05:38.323Z","comments":true,"path":"api/articles/LoggingMessage.json","excerpt":"<h1 id=\"Logging-LoggerMessage\"><a href=\"#Logging-LoggerMessage\" class=\"headerlink\" title=\"Logging - LoggerMessage\"></a>Logging - LoggerMessage</h1><p>原先在記錄Log都會使用微軟提供LoggingExtensions方法，最近朋友聊天分享給我<code>LoggerMessage.cs</code>與<code>LoggerMessageAttribute.cs</code>。於是研究一下並記錄一下。</p>\n<p>這方式把寫Log的方式更好的管理及使用強型別方式。</p>","keywords":null,"cover":null,"content":null,"text":"Logging - LoggerMessage原先在記錄Log都會使用微軟提供LoggingExtensions方法，最近朋友聊天分享給我LoggerMessage.cs與LoggerMessageAttribute.cs。於是研究一下並記錄一下。這方式把寫Log的方式更好的管理","link":"","raw":null,"photos":[],"categories":[{"name":"WebAPI","slug":"WebAPI","count":6,"path":"api/categories/WebAPI.json"},{"name":"Log","slug":"WebAPI/Log","count":1,"path":"api/categories/WebAPI/Log.json"}],"tags":[{"name":".Net Core","slug":"Net-Core","count":10,"path":"api/tags/Net-Core.json"},{"name":"WebAPI","slug":"WebAPI","count":2,"path":"api/tags/WebAPI.json"},{"name":"2024","slug":"2024","count":11,"path":"api/tags/2024.json"}]}]}